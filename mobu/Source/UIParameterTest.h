/*
 * Mobius parameter definitions.
 * This file is generated by the mobu tool.
 *
 * Actually no, this file can stay static and we can
 * put all of the generated code in UIParameterClasses.h and .cpp
 *
 */

#pragma once

// for juce::var only
#include <JuceHeader.h>

// do not necessarily need this with generated files
#include "SystemConstant.h"

//////////////////////////////////////////////////////////////////////
// Enumerations
//////////////////////////////////////////////////////////////////////

/**
 * The type of the parameter.
 * The canonical type names found in the generator source files are:
 *
 *   int, bool, enum, string
 *
 * Type names must follow those names with capitalization.
 */
typedef enum {

	TypeInt,
	TypeBool,
	TypeEnum,
	TypeString

} UIParameterType;

/**
 * Parameter scope.
 * Canonical names: global, preset, setup, track
 *
 * The corresponding model classes are:
 *
 * MobiusConfig, Preset, Setup, SetupTrack
 *
 * MobiusConfig is the only one whose name differs from the canonical name.
 * Should we have a model for mapping these?
 */
typedef enum {

    ScopeNone,
    ScopeGlobal,
    ScopePreset,
    ScopeSetup,
    ScopeTrack

} UIParameterScope;

//////////////////////////////////////////////////////////////////////
// Class
//////////////////////////////////////////////////////////////////////

/**
 * Continue using const char* for strings so we don't have to
 * rip up the model editors yet, but move to juce::String eventually
 * Especially for the arrays.
 *
 * SystemConstant defines name and displayName
 */
class UIParameter : public SystemConstant
{
  public:

	UIParameter();
    // don't think we'll be needing subclasses yet
	virtual ~UIParameter();

    UIParameterScope scope = ScopeGlobal;
	UIParameterType type = TypeInt;
    
    /**
     * True if it supports multiple values.
     */
    bool multi = false;

    /**
     * For TypeEnum, the  set of allowed values.
     */
    const char** values = nullptr;

    /**
     * For TypeEnum, the set of alternate display names.
     */
	const char** valueLabels = nullptr;

    /**
     * For TypeInt, the lowest allowed value.
     */
    int low = 0;

    /**
     * For TypeInt, the highest allowed value.
     * If the dynamic flag is set, the high value must be calculated
     * at runtime.
     */
    int high = 0;

    /**
     * For TypeInt, a few parameters may have a default value other
     * than zer.  Typically this will be the upper end of a range
     * or the center.
     */
    int defaultValue = 0;

    /**
     * Indiciates the high value must be calculated at runtime.
     */
    bool dynamic = false;
    
    /**
     * Indicates that the value should be displayed as a positive
     * or negative integer with zero at the center of the low/high range.
     */
    bool zeroCenter = false;

    /**
     * Indicates that this can be highlighted in the UI as a sweepable control.
     * These are the most common parameters used in bindings and can be
     * separated from other parameters to make them easier to find.
     * Explore other presentation categories like "advanced".
     */
    bool control = false;

    /**
     * Indicates that this parameter exists only at runtime and will not
     * be saved in a configuration file.  It can still be used in bindings
     * but will be omitted from configuration file generators.
     */
    bool transient = false;

    /**
     * Indiciates that this parameter may use juce::var for value access.
     * Since we're redesigning this model just for the UI, this can
     * eventually be the default and we can remove ExValue
     */
    bool juceValues = false;

    /**
     * In a few cases the names were changed to be more consistent
     * or obvious or because I liked them better.  In order to correlate
     * the new parameter definitions with the old ones, this would
     * be the name of the old Parameter.
     */
    const char* coreName = nullptr;
    
    //
    // Others from the old model to consider
    //

    // bindable: true if this is may be used in a Binding
    // resettable: used at runtime to indiciate that the parameter
    //  value is changed after the Reset function, don't think this
    //  is interesting for the UI

    //////////////////////////////////////////////////////////////////////
    //
    // Value Access Functions
    //
    // At least one set of ExValue or juce::var functions must be implemented
    // in the subclass. Starting with ExValue being required and juce::var
    // being optional, but need to switch the UI to use juce::var
    // 
    //////////////////////////////////////////////////////////////////////

    virtual void getValue(void* object, class ExValue* value) = 0;
    virtual void setValue(void* object, class ExValue* value) = 0;

    // shouldn't this just return a juce::var by value?
    // implementations are stubbed and only used if juceValues is set
    virtual void getValue(void* object, juce::var& value) {
    }
    
    virtual void setValue(void* object, juce::var& value) {
    }

    /**
     * Access the value as a normalized ordinal integer.
     * The default implementation uses ExValue.
     * This works for all types except TypeString.
     * Since TypeString is rare, think about having this be the
     * one all the subclasses must implement and only bust out
     * value containers for the very few random strings.
     */
    int getOrdinal(void* object);
    void setOrdinal(void* object, int value);
    
    //////////////////////////////////////////////////////////////////////
    //
    // Coercion Utilities
    //
    // These are not generated.
    // Various utility functions used by the UI to display parameter values
    //
    //////////////////////////////////////////////////////////////////////
    
    /**
     * Convert a string containing a TypeEnum value into an ordinal.
     * Think: This could handle both values and displayValues if we
     * can assume a capitalization convention.
     *
     * todo: original model had getEnum trace a warning if the enumeration
     * was out of range and returned zero.  getEnumNoWarn did not trace
     * and returned -1.  Do we need those?
     *
     * Currently these will return zero if the value is not within the enumeration.
     */
    int getEnumOrdinal(juce::String value);
    int getEnumOrdinal(const char* value);

    /**
     * Convert an enumeration ordinal into the internal value symbol.
     */
    const char* getEnumName(int ordinal);
    
    //////////////////////////////////////////////////////////////////////
    // Backward compatibility
    //
    // Value and anumeration utilities for older code until they can be converted.
    //
    //////////////////////////////////////////////////////////////////////
    
	/**
	 * Convert a string value to an enumeration ordinal value.
     * If the value is not in the enum, an error is traced and zero is returned.
	 */
	int getEnum(const char *value);

	/**
	 * Convert a string value to an enumeration ordinal value, returning
     * -1 if the value isn't in the enum.
	 */
	int getEnumNoWarn(const char *value);

	/**
	 * Convert an ExValue with an string or a number into an ordinal.
	 */
	int getEnum(ExValue *value);

    //////////////////////////////////////////////////////////////////////
    //
    // Global Parameter Registry
    //
    //////////////////////////////////////////////////////////////////////

    static std::vector<UIParameter*> Parameters;
    static void dumpParameters();
	static UIParameter* find(const char* name);
	static UIParameter* findDisplay(const char* name);

};

/*** GENERATED ***/

extern UIParameter* UIParameterFoo;
extern UIParameter* UIParameterBar;
