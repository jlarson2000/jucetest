/**
 * Generator for Mobius UIParameter definition objects.
 * 
 * Some parameterers are hard and after much flailing around I've arrived at
 * the fact that the get/set functions we're generating here are only relevant for
 * the configuration editor as a convenience.  Other execution contexts for parameters
 * won't use them so we don't have to mess around with all of the implications of
 * a type=Structure parameter means.  The UIParameter model just needs to capture as much
 * of the static definition as possible, with convenient boiler plate accessors for
 * parts of the system, but it can't be everything that has to be coded around parameters.
 *
 * The old code wired in code to handle Actions and Exports.  Start doing that outside
 * with some sort of ParameterContext that knows how to deal with parameters in a way
 * appropriate for that context.  If that fleshes out nicely then we could move all of
 * the get/set code into ConfigEditorContext maybe.
 * 
 * Terms:
 *
 *    parameterName
 *      the intenal unique name for this parameter in "lower camel" form
 *      where the initial letter is lower case and subsequent "words" are capitalized
 *      examples: subcycles, quantizeMode, emptyLoopAction
 *
 *    coreName
 *      the name of this parameter in core code, when we want to start using a better name
 *
 *    displayName
 *      the name shown in the UI, usually derived by inserting spaces in cameled words
 *      and capitalizing the first letter
 *      examples: Subcycles, Quantize Mode, Empty Loop Action
 *
 *      When displayName is omitted in the XML, the above rule is automatically applied
 *      When displayName is included, it is used without modification.
 *
 *   codeName
 *      the name of this parameter as it appears in methods that get or set the value
 *      in the containing class.  this is usually automatically generated by applying an
 *      initial capital to the  parameterName.
 *      examples:  Subcycles, QuantizeMode, EmptyLoopAction
 *
 *   qualName
 *     the prefix "UIParameter" followed by codeName
 *     examples: UIParameterSubcyclesClass
 *
 *   className
 *      the full name of the UIParameter subclass
 *      example: UIParameterSubcyclesClass
 *
 *   objName
 *     the full name of the static instance of this class
 *     example: UIParameterSubcyclesObj
 *     todo: reconsider the need to have pair of static objects and
 *     an extern pointer to it.  Just use the object and & it when we need a pointer.
 *    
 *    scopeName
 *      the internal name of the parameter scope, from the scope='' attribute
 *      examples: global, preset, setup, track
 *
 *    scopeClassName
 *      the class name of the object that implements this scope
 *      examples: MobiusConfig, Preset, Setup, SetupTrack
 *
 *    scopeEnumName
 *      the name of the UIParameterScope enumeration item for each scope
 *      examples: ScopeGlobal, ScopePreset
 *
 *   getterName/setterName
 *     the full name of the method that gets or sets the value, combines the
 *     codeName with is, get, or set.   "is" is used for the getter names of
 *     boolean values.
 *     examples: getSubcycles, setQuantizeMode, isOverdubQuantized
 *     
 *    typeName
 *      the XML type names: int, bool, string, enum, structure
 *
 *    typeEnumName
 *      the name of the UIParameterType enumeration item for each type
 *      examples: TypeInt, TypeBool
 *
 *    typeCodeName
 *      the name of this type when used in function names, usually just the capitalized
 *      typeName.  
 *      examples: Int, Bool, String
 *      typically used when getting or setting values in an ExValue: getInt, setString
 *      may need different conventions when we start using juce::var
 *      for type=enum, it will always be Int
 *
 *    enumName
 *      for type=enum, the code name of the enumerated type of this value
 *      used for casting an integer to the enumeration required by the setter method
 *      this defaults to the scopeClassName + :: + codeName
 *      examples: Preset::QuantizeMode
 *
 * Any of these XML attributes may be present to influence code generation.
 * When not found the default rules are applied.
 *
 * Implications
 *
 * So we don't have to fully specify a parameter definition in XML, the following
 * implicit assumptions are made:
 *
 *    type missing becomes type='int'
 *    values set forces type='enum'
 *    multi='true' forces type='string' (see below)
 *    multi='true' forces noBinding
 *
 * Multi Values
 *
 * There are a small number of parameters that have multi='true'  these are always
 * also type='string'
 * todo: since multi implies type, consider just having that in the type name
 *   like multistring, strings, stringlist
 *
 * The parameters that currently have this treatment are:
 *     MobiusConfig::altFeedbackDisables
 *     MobiusConfig::focusLockFunctions
 *     MoibusConfig::muteCancelFunctions
 *     MobiusConfig::confirmationFunctions
 *     Setup::resetables
 *
 * The accessor methods use the old StringList model.  
 * They cannot appear in bindings.
 *
 * Setup::resetables appears to be a derived parameter, set in SetupDialog like this:
 * 
 *     StringList* paramNames = new StringList();
 *     for (i = 0 ; Parameters[i] != NULL ; i++) {
 *        Parameter* p = Parameters[i];
 *        // !! not everything in setup scope needs to be resettable
 *         if (p->resettable)
 *          paramNames->add(p->getDisplayName());
 *
 * The "resettable" flag was only found in a subset of SetupTrack parameters.
 * Unclear if this flag was ever turned off if you edited the Setup and changed
 * the resetables list.  Need to rethink this concept.
 *
 * The XML representation was inconsistent.  Some converted it to a CSV but
 * at least one used an explded list of <String> elements.  In the New World, we will
 * always use a csv in XML.  Old code converted this to a CSV seting for getValue/setValue.
 *
 * For parameter value consumers we could either expose StringList or a Juce collection,
 * or we can just expose the CSV string and let conversion happen elsewhere.
 * But because core code still expects StringList from the Setup methods, we have to
 * support that in the UIParameter wrapper.  The resulting getter/setter code looked like this:
 *
 * void FocusLockFunctionsParameterType::getValue(MobiusConfig* c, ExValue* value) {
 *    StringList* l = c->getFocusLockFunctions();
 *    if (l == NULL)
 * 	    value->setString(NULL);
 *    else {
 *      char* str = l->toCsv();
 *      value->setString(str);
 *      delete str;
 *    }
 *}
 *
 * This sucks because the generating the CSV allocates memory which is not okay in the kernel.
 * But since these were never used in bindings, it matters less.  It's more likely that
 * this could be used in a script, but that too is rare.  I'd like to standaardize
 * on keeping these as CSVs in the model but this requires new accessor methods like
 *     getFocusLockFunctionsCsv()
 *
 * since the old ones still have to use StringList for core code.
 * Needs thought.
 *
 * For now, generated parameter accessors will assume the getter and setter names
 * have "Csv" appended and the values can be treated as simple strings.
 *
 * ExValue does support Stringlist as does juce::var though.
 *
 * 
 * Step Sequences
 *
 * speedSequence and pitchSequence use a special model for what is essentially
 * type=int, multi=true.  This is StepSequence.  For the Parameter interface this
 * was a space delimited list of positive or negative numbers.  NOT a Csv.
 *
 * We can either add code to the getter/setter to do this transfrmation or
 * add the getSpeedSequenceString methods.
 *
 * Structures
 *
 * See structure-parameters.txt for why this is hard
 * In the generated code for the config editor, they will be left as name strings.
 *
 */
 
#include <iostream>
using std::cout;
using std::endl;

#include <JuceHeader.h>

#include "ParameterGenerator.h"

ParameterGenerator::ParameterGenerator()
{
}

ParameterGenerator::~ParameterGenerator()
{
}

bool ParameterGenerator::generate(juce::String fileName, bool testMode)
{
    // unfortunately when running under the debugger the working directory
    // is where the .exe is, not Source which is where you are when you run
    // it interactively.  Probably a way to set this in VisualStudio but it might
    // get lost when Projucer regenerates the solution
    // juce::File file(juce::File::getCurrentWorkingDirectory().getChildFile(fileName));
    juce::String rootPath = "c:/dev/jucetest/mobu/Source";
    
    juce::File file(juce::File(rootPath).getChildFile(fileName));
    bool success = false;
    
    cout << "Reading definition file: " + file.getFullPathName() << endl;

    // this is where parsing actually happens, if nullptr is returned
    // use getLastParseError
    juce::XmlDocument doc(file);
    std::unique_ptr<juce::XmlElement> el = doc.getDocumentElement();
    if (el == nullptr) {
        cout << "Parse error:" << doc.getLastParseError() << endl;
    }
    else {
        code.clear();
        // two options here, can build a memory model of the parameter definitions
        // then generate code when it parses fully or just generate code on the fly
        // skip having an intermediate model 
        success = parseParameters(el.get());
        if (success) {
            juce::String basePath = rootPath + "/UIParameter";
            success = code.generate(basePath, testMode);
            if (!success)
              cout << "Failed to generate files" << endl;
        }
    }
    return success;
}

bool ParameterGenerator::expect(juce::XmlElement* el, const char* elementName)
{
    bool ok = el->hasTagName(elementName);
    if (!ok) {
        // should be able to get the parent for context
        cout << "Unexpected element name: " + el->getTagName() << endl;
    }
    return ok;
}

juce::String ParameterGenerator::require(juce::XmlElement* el, const char* attname)
{
    juce::String value = el->getStringAttribute(attname);
    if (value.length() == 0) {
        cout << "Missing required " + el->getTagName() + " attribute " + attname << endl;
    }
    return value;
}

bool ParameterGenerator::parseParameters(juce::XmlElement* el)
{
    bool success = false;
    
    if (expect(el, "Parameters")) {
        juce::XmlElement* child = el->getFirstChildElement();
        while (child != nullptr) {
            success = parseParameterScope(child);
            child = child->getNextElement();
            if (!success)
              break;
        }
    }
    return success;
}

bool ParameterGenerator::parseParameterScope(juce::XmlElement* el)
{
    bool success = false;
    
    if (expect(el, "ParameterScope")) {
        currentScope = el->getStringAttribute("name");
        cout << "Entering scope " << currentScope << endl;

        // don't need to do this for hreaders but code needs
        // to be broken up
        code.targetCode();
        code.add("\n//******************** " + currentScope + "\n\n");

        juce::XmlElement* child = el->getFirstChildElement();
        while (child != nullptr) {
            success = parseParameter(child);
            child = child->getNextElement();
            if (!success)
              break;
        }
    }
    return success;
}

bool ParameterGenerator::parseParameter(juce::XmlElement* el)
{
    bool success = false;
    
    if (expect(el, "Parameter")) {
        juce::String name = require(el, "name");
        if (name.length() > 0) {
            cout << "Parameter " + name << endl;
            juce::String codeName = formatCodeName(name);
            code.targetHeader();
            code.indent("extern UIParameter* UIParameter");
            code.add(codeName);
            code.add(";\n");
            generateOldCode(el);
        }
        success = true;
    }
    return success;
}

/**
 * Now it starts getting hairy.
 * This is the old style of parameter code.
 */
void ParameterGenerator::generateOldCode(juce::XmlElement* el)
{
    juce::String name = require(el, "name");
    juce::String coreName = el->getStringAttribute("coreName");
    juce::String codeName = formatCodeName(name);
    juce::String qualName = "UIParameter" + codeName;
    juce::String className = qualName + "Class";

    // no longer comes from the Parameter element, get it from
    // ParameterScope and save it in the "scope" member
    // juce::String scopeName = el->getStringAttribute("scope");
    juce::String scopeClass = formatScopeClass(currentScope);
    
    // type: defaults to int, forced enum if multi
    bool isMulti = (el->getStringAttribute("multi").length() > 0);
    juce::String typeName = el->getStringAttribute("type");
    if (isMulti) {
        typeName = "string";
    }
    else if (typeName == "structure") {
        typeName = "string";
    }
    else if (typeName.length() == 0) {
        if (el->getStringAttribute("values").length() > 0)
          typeName = "enum";
        else
          typeName = "int";
    }
    juce::String typeCodeName = formatTypeCode(typeName);


    code.targetCode();
    code.add("\n////////////// " + codeName + "\n\n");
    
    // class definition

    code.add("class " + className + " : public UIParameter\n");
    code.add("{\n");
    // indent always does 4 and public: or probably anything
    // with a colon, emacs auto indents with 2
    code.add("  public:\n");
    code.incIndent();
    // constructor declaration
    code.indent(className + "();\n");
    // value accessors
    code.indent("void getValue(void* obj, class ExValue* value) override;\n");
    code.indent("void setValue(void* obj, class ExValue* value) override;\n");
    code.decIndent();
    code.add("};\n");
    
    // constructor
    
    code.add(className + "::" + className + "()\n");
    code.add("{\n");
    code.incIndent();
    code.indent("name = \"" + name + "\";\n");
    code.indent("displayName = \"" + formatDisplayName(name) + "\";\n");
    if (coreName.length() > 0)
      code.indent("coreName = \"" + coreName + "\";\n");
    // note that this isn't the code class name, it's just the upcased xml name
    code.indent("scope = Scope" + formatScopeEnum(currentScope) + ";\n");
    code.indent("type = Type" + typeCodeName + ";\n");
    addInitializer(el, "low");
    addInitializer(el, "high");
    addInitializer(el, "defaultValue");
    addOption(el, "multi");
    addOption(el, "dynamic");
    addOption(el, "zeroCenter");
    addOption(el, "control");
    addOption(el, "transient");
    addOption(el, "juceValues");
    addOption(el, "noBinding");
    // resettable means the parameter will reset it's value when the loop is reset
    // used in core, won't be used out here for awhile
    addOption(el, "resettable");
    // this means that setting the parameter will schedule an event
    // don't need above core for awhile
    addOption(el, "scheduled");
    
    code.decIndent();
    code.add("}\n");

    // getValue

    code.add("void " + className + "::getValue(void* obj, ExValue* value)\n");
    code.add("{\n");
    code.incIndent();
    // the part where we cast the void* to the container class
    juce::String downcast = "((" + scopeClass + "*)obj)->";
    // the part of the method name after get/set
    juce::String methodName = codeName;
    if (coreName.length() > 0)
      methodName = formatCodeName(coreName);
        
    if (typeCodeName == "Structure") {
        // these are fundamentally  type='string' with a lot of extra baggage
        code.indent("value->setString(" + downcast);
        code.add("get" + methodName + "());\n");
    }
    else if (isMulti) {
        // convert StringList to CSV
        // could use ExValueList or juce::var too
        // instead of setString(getSomething()) use setString(getCsv(getSomething()))
        // where getCsv() is defined in the UIParameter base class
        code.indent("value->setString(getCsv(" + downcast);
        code.add("get" + methodName + "()));\n");
    }
    else {
        code.indent("value->set" + typeCodeName + "(" + downcast);
        juce::String getVerb = (typeCodeName == "Bool") ? "is" : "get";
        code.add(getVerb + methodName + "());\n");
        code.decIndent();
    }
    code.add("}\n");
    
    // setValue
    
    code.add("void " + className + "::setValue(void* obj, ExValue* value)\n");
    code.add("{\n");
    code.incIndent();
    if (typeCodeName == "Structure") {
        code.indent(downcast + "set" + methodName + "(");
        code.add("value->get" + typeCodeName + "());\n");
        code.decIndent();
    }
    else if (isMulti) {
        // instead of setSomething(value->getString()) use
        // setSomething(getStringList(value->getString()))
        // where getStringList() is defined in the UIParameter base class
        code.indent(downcast + "set" + methodName + "(getStringList(");
        code.add("value->get" + typeCodeName + "()));\n");
        code.decIndent();
    }
    else {
        code.indent(downcast + "set" + methodName + "(");
        if (typeName == "enum") {
            // cast to the internal enum
            code.add("(");
            juce::String enumName = el->getStringAttribute("enumName");
            if (enumName.length() == 0) {
                // Preset enumerations are inside the Preset
                if (currentScope == "preset")
                  enumName += "Preset::";
                enumName += codeName;
            }
            code.add(enumName);
            code.add(")");
        }
        code.add("value->get" + typeCodeName + "());\n");
        code.decIndent();
    }
    code.add("}\n");

    // static object
    juce::String objName = qualName + "Obj";
    code.add(className + " " + objName + ";\n");
    // and finally our pointer
    code.add("UIParameter* " + qualName + " = " + "&" + objName + ";\n");
}

void ParameterGenerator::addInitializer(juce::XmlElement* el, const char* name)
{
    juce::String jname(name); 
    if (el->hasAttribute(jname)) 
      code.indent(jname + " = " + el->getStringAttribute(jname) + ";\n");
}

void ParameterGenerator::addOption(juce::XmlElement* el, const char* name)
{
    juce::String opname(name);
    
    if (el->hasAttribute("options")) {
        // this will be a csv but we don't have to split it up
        juce::String options = el->getStringAttribute("options");
        if (options.contains(opname)) {
            code.indent(opname + " = true;\n");
        }

    }
}

juce::String ParameterGenerator::capitalize(juce::String xmlName)
{
    juce::String capName;
    
    if (xmlName.length() > 0) {
        capName += juce::CharacterFunctions::toUpperCase(xmlName[0]);
        capName += xmlName.substring(1);
    }
    return capName;
}    

/**
 * "code" name is the name used when combined with the get/set
 * functions on the target class.  It is usually just
 * an initial capital conversion.
 *
 * Probably going to have some more complex substitutions.
 */
juce::String ParameterGenerator::formatCodeName(juce::String xmlName)
{
    return capitalize(xmlName);
}

/**
 * Display name rules are initial capital followed by space
 * delimited words for each capital in the internal name.
 */
juce::String ParameterGenerator::formatDisplayName(juce::String xmlName)
{
    juce::String displayName;

    for (int i = 0 ; i < xmlName.length() ; i++) {
        juce::juce_wchar ch = xmlName[i];
        
        if (i == 0) {
            ch = juce::CharacterFunctions::toUpperCase(ch);
        }
        else if (juce::CharacterFunctions::isUpperCase(ch)) {
            displayName += " ";
        }
        displayName += ch;
    }

    return displayName;
}

/**
 * Convert the XML scope name to the name of one of the Scope
 * constants.  Just an upcase.
 */
juce::String ParameterGenerator::formatScopeEnum(juce::String xmlName)
{
    return capitalize(xmlName);
}

/**
 * Convert the XML scope name to the name of the target class.
 */
juce::String ParameterGenerator::formatScopeClass(juce::String xmlName)
{
    const char* className = "???";

    if (xmlName == juce::String("global"))
      className = "MobiusConfig";
    
    else if (xmlName == juce::String("preset"))
      className = "Preset";
    
    else if (xmlName == juce::String("setup"))
      className = "Setup";
      
    else if (xmlName == juce::String("track"))
      className = "SetupTrack";
      
    else
      className = "???";
        
    return juce::String(className);
}

/**
 * Format an XML type name into the name used in the ExValue get/set functions
 * enums are going to be more complicated
 */
juce::String ParameterGenerator::formatTypeCode(juce::String xmlName)
{
    const char* typeName = "???";

    if (xmlName == juce::String("int"))
      typeName = "Int";

    else if (xmlName == juce::String("bool"))
      typeName = "Bool";

    else if (xmlName == juce::String("string"))
      typeName = "String";

    else if (xmlName == juce::String("enum")) {
        // this becomes Int with extra casting
        typeName = "Int";
    }
    else if (xmlName == juce::String("structure")) {
        typeName = "Structure";
    }

    return juce::String(typeName);
}

      
             
