/**
 * Auto generated by Projucer
 * Not sure how much we can do with this without Projucer overwriting
 * it if the configuration changes.
 */

#include <JuceHeader.h>

#include "MainComponent.h"

#include "Supervisor.h"
#include "ui/JuceUtil.h"
#include "util/Trace.h"

MainComponent::MainComponent()
{
    // Jeff's component tree debugging hack
    setName("MainComponent");

    // startup can do a lot of thigns, perhais we should have different
    // phases, first to load any configuration related to the initial window size
    // and device configuration, and then another to start up the engine
    // having some ugly initialization timing issues trying to do too much
    // in the MainComponent constructor, is there a convenient hook to defer that?
    supervisor.start();
    
    // redirect key events to the global listener
    addKeyListener(&KeyTracker::Instance);

    // Projucer:
    // Some platforms require permissions to open input channels so request that here
    // 
    // jsl - the RuntimePermissions part was generated by Projucer
    // the second arg to request() is a RuntimePermissions::Callback which is defined as
    //   using RuntimePermissions::Callback = std::function<void (bool)>
    // so it's a "lambda" that I need to learn about, see lambda.txt for random notes
    // in olden terms it's an anonymous function pointer to a "void(bool)" function
    // what happens is request() will do what it does and then call the function
    // pointer passing a bool "granted" argument.  This generated function will
    // call this class' setAudioChannels method with either 2 or 0 for the first
    // arg which is the number of input channels, depending on whether the request
    // was granted.  The second arg 2 is the number of output channels.
    //
    // Apparently in some contexts you are not allowed to record audio so this configures
    // the AudioAppComponent to not have any input channels.
    // if the recordAudio permission is not required, or if it was granted then we ask
    // for 2 input channels.  
    // it is unclear if I need this, it might have to do with mobile platforms
    // I've never encountered an environment I would use that didn't support
    // recording.  In fact if it doesn't we may as well stop now because loopers
    // kinda need to record
    //
    // for Mobius need to revisit how many channels we'll use, start with 2 to get
    // things going but I've historically allowed as many as the device suports
    // so we can route different channels to different tracks, unclear what this
    // means since if you set say 8 and the device only supports 2 what does it do?
    // if this determines the size of the audio bueffers oassed  to getNextAudioBlock
    // then it's going to waste space with samples that don't actually come from the device

    // want to configure these?
    // not remembering if Mobius ever really supported more than one pair of channels
    // old dialog only let you select one device, new Juce selector makes you select
    // pairs of RME channels but you can't select more than one
    int inputChannels = 4;
    int outputChannels = 2;
    
    if (juce::RuntimePermissions::isRequired (juce::RuntimePermissions::recordAudio)
        && ! juce::RuntimePermissions::isGranted (juce::RuntimePermissions::recordAudio)) 
    {
        juce::RuntimePermissions::request (juce::RuntimePermissions::recordAudio,
                                           [&] (bool granted) {
                                               setAudioChannels (granted ? inputChannels : 0, outputChannels); });
    }
    else
    {
        setAudioChannels (inputChannels, outputChannels);
    }

    // Normally you're supposed to set the size of the component after adding
    // children so the resize is triggered and cascades down.  For us,
    // we might want to let the child configuration determine the optimal
    // window size and pass it back up.  Or I guess just let Supervisor do
    // this when ready.

    // start with a size large enough to give us room but still display
    // on most monitors
    setSize (1200, 800);
}

MainComponent::~MainComponent()
{
    // Projucer: This shuts down the audio device and clears the audio source.
    // Docs:
    // Shuts down the audio device and clears the audio source.
    // This method should be called in the destructor of the derived class
    // otherwise an assertion will be triggered.
    shutdownAudio();

    // this must be done AFTER shutdownAudio so we don't delete things
    // out from under active audio threads
    supervisor.shutdown();
}

//////////////////////////////////////////////////////////////////////
//
// AudioAppComponent
//
//////////////////////////////////////////////////////////////////////

/**
 * From Projucer:
 * see this thread when you get ready to start handling audio buffers
 * https://forum.juce.com/t/using-smart-pointers-with-juce-functions-that-want-raw-pointers/29229/12
 * 
 * This function will be called when the audio device is started, or when
 * its settings (i.e. sample rate, block size, etc) are changed.
 * 
 * You can use this function to initialise any resources you might need,
 * but be careful - it will be called on the audio thread, not the GUI thread.
 *
 * For more details, see the help for AudioProcessor::prepareToPlay()
 *
 * From the docs:
 *
 * Tells the source to prepare for playing.
 * An AudioSource has two states: prepared and unprepared.
 * 
 * The prepareToPlay() method is guaranteed to be called at least once on an 'unprepared'
 * source to put it into a 'prepared' state before any calls will be made to
 * getNextAudioBlock(). This callback allows the source to initialise any resources it
 * might need when playing.
 * 
 * Once playback has finished, the releaseResources() method is called to put the stream
 * back into an 'unprepared' state.
 *
 * Note that this method could be called more than once in succession without a matching
 * call to releaseResources(), so make sure your code is robust and can handle that kind
 * of situation.
 *
 * samplesPerBlockExpected
 *   the number of samples that the source will be expected to supply each time
 *   its getNextAudioBlock() method is called. This number may vary slightly, because it
 *   will be dependent on audio hardware callbacks, and these aren't guaranteed to always
 *   use a constant block size, so the source should be able to cope with small variations.
 *
 * sampleRate
 *  the sample rate that the output will be used at - this is needed by sources such
 *  as tone generators.
 */
void MainComponent::prepareToPlay (int samplesPerBlockExpected, double sampleRate)
{
    supervisor.prepareToPlay(samplesPerBlockExpected, sampleRate);
}

/**
 * From Projucer
 *
 * Your audio-processing code goes here!
 * For more details, see the help for AudioProcessor::getNextAudioBlock()
 * Right now we are not producing any data, in which case we need to clear the buffer
 * (to prevent the output of random noise)
 *
 * From the docs:
 *
 * Called repeatedly to fetch subsequent blocks of audio data.
 * 
 * After calling the prepareToPlay() method, this callback will be made each time the audio
 * playback hardware (or whatever other destination the audio data is going to) needs another
 * block of data.
 *
 * It will generally be called on a high-priority system thread, or possibly even an interrupt,
 * so be careful not to do too much work here, as that will cause audio glitches!
 */
void MainComponent::getNextAudioBlock (const juce::AudioSourceChannelInfo& bufferToFill)
{
    // bufferToFill.clearActiveBufferRegion();
    supervisor.getNextAudioBlock(bufferToFill);
}

/**
 * From Projucer:
 * This will be called when the audio device stops, or when it is being
 * restarted due to a setting change.
 *
 * From the docs:
 * This will be called when the source is no longer going to have its getNextAudioBlock()
 * method called, so it should release any spare memory, etc. that it might have allocated
 * during the prepareToPlay() call.
 * 
 * Note that there's no guarantee that prepareToPlay() will actually have been called
 * before releaseResources(), and it may be called more than once in succession, so
 * make sure your code is robust and doesn't make any assumptions about when it will be called.
 */
void MainComponent::releaseResources()
{
    supervisor.releaseResources();
}

//////////////////////////////////////////////////////////////////////
//
// Component
//
//////////////////////////////////////////////////////////////////////

void MainComponent::paint (juce::Graphics& g)
{
    // You can add your drawing code here!

    // jsl - start with basic black, always in style
    // DisplayManager can override this, should we even bother?
    g.fillAll (juce::Colours::black);
}

/**
 * Projucer:
 * This is called when the MainContentComponent is resized.
 * If you add any child components, this is where you should
 * update their positions.
 */
void MainComponent::resized()
{
    // jsl - This does not cascade through the children automatically
    // unless you call setSize on them, it's unusual here because of the
    // deferred adding of children by DisplayManager, so assume we have
    // something and let it fill us up with hope and wonder
    juce::Component* child = getChildComponent(0);
    if (child != nullptr)
      child->setBounds(getLocalBounds());
}
