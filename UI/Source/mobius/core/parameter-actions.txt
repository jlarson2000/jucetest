
New way to do Parameters

Fundamentally what we need to define for each parameter is:

   name
     - used in bindings, scripts
     - that's what fundamentally defines a parameter, it is something
       with a name that has to be located at runtime, can't be compiled in

   value properties
     - information about the types of value the parameter can have
     - necessary for structure storage

   structure/storage accessors
     - most parameters are stored in C++ class objects
     - class storage may be used for persistent storage, runtime access, or both
     - need get/set functions to move values back and forth
     - parameters that do not exist in a structure are "transient"
       and can only be access at runtime

   runtime accessors
     - when the system is running, parameter values may be read from
       a location other than the persistent structure storage
     - same with changing a parameter value
     - changing a parameter value may have side effects beyond just
       depositing a value somewhere

   editing properties
     - characteristics of the parameter necessary to generate user interfaces
     - displayName, allowedValues, low, high
     - generally not necessary at runtime

   runtime properties
     - behavioral aspects of the parameter when it is used at runtime
     - scheduled, resetRetain

We are currently generating code for everything except runtime accessors because
everything else can be implemented against the shared model.  "model" is a good name,
a parameter has to be materialized in a model, this can be the "persistent" model
or the "runtime" model.

Runtime accessors are harder for the UI because they have dependencies on the engine
internals that the UI should not be exposed to.  Further code generation needs
to be done without requiring linkage to runtime code.  This can be abstracted by
defining interfaces:

   ParameterHandler
     - interface of an object that receives requests to get or set a parameter at runtime
     - could also be ParameterContext

   ReadContext
     - information about the way in which a parmeter is being read
     - this is currently what Export does

   WriteContext
     - information about the way in which a parameter is being written
     - this is UIAction or Action

Without further abstraction on the read/write context, what we need to generate is:

class ParameterRuntimeContext

   void setSubcycles(UIAction* action)
   ExValue getSubcycles(Export* export)

structure context looks like

   void setSubcycles(void* object, ExValue value)
   ExValue getSubcycles(void* object)

To compile, UIAction and Export need to have interfaces but don't need implementations.

For runtime, an interface for the ParameterHandler can be generated.  This must
be implemented by a Mobius level class that has all the imlementations.  The initial
implementation can be generated, but this needs to be manually edited.  No, implementation
can't be generated because we'll be designing this to eliminate redundant paths which can't
be generated, only the few exceptiosn need per-parameter implementations.

Most runtime parameter accessors reduce to the structure accessors.

Damn, structure editing can do this to.  This goes back to the execution context
or whatever I was calling it.  You're in a context (editor, runtime) that needs to
get/set a parameter, how is that implemented.

The fundamental problem that needs to be solved is name-to-implementation lookup
everything else can be dynamic.  Well not entirely, the engine does not need
concrete Parameter objects, because it operates against a parameter model.  The UI
doesn't?  Hmm, instead of this

    addField(SubcyclesParameter)

you could do this

    addField("subcyclesParameter")

The name lookup happens at runtime to produce an object with parameter information
but this doesn't have to be a static object.  Where it becomes necessary to have
code is the dispatch from a parameter name to the code necessary to implement the
parameter behavior.

class Parameter
  name, flags, all the current stuff
  give parameters an "id" const int which is basically the ordinal but it is fixed
  so code can test on it

  read from XML file

class ParameterHandler

     void setSubcycles(ExValue)
     ExValue getSubcycles();

Need something to pass arbitrary values but the main thing is a concrete compile time
function pointer to something that handles it

class PresetParameterHandler
  - constructed with a Preset
  - impleemnts getSubcycles/setSubcycles against that Preset

ParameterHandlers can be LAYERED
  - XMLParameterHandler uses PresetParameterHandler internally to get/set values
  - converts those values to/from XML

Would be nice if all parameters could be fundamtally set with ordinals that's
the only code that needs to be generated

    void setSubcycles(int)
    int getSubcycles();

Only contexts that require passing complex values need to implement an ExValue
method subset, the default just uses the ordinal methods and wraps them.

Those special accessors depend on the Calling Context.  Even though a parameter
might support String values, if the caller isn't prepared to deal with them those
can't be used.  The caller is either unable to use those parameters (e.g. host parameter bindings)
or it must take extra steps to call more complex accessors which may or may not be overloaded.

Here is what I want:

  - need to add a new parameter, define the base definition in XML
  - implement a pair of get/set(int) methods in a class

How the caller gets that integer value is defined in the calling context.

So there are two things:

   ParameterCallingContext
      - where you are and what objects you have access to to convey the parameter value
        ExValue (scripts), juce::value(UI), Export (engine), UIAction (engine)

      - this is where generators can be used, you need a get/set that deals with the
        "parameter value payload" but how those are implemented is hand generated

Anyway, same is true for Functions

   FunctionContext

        result = doRecord(payload)

The doRecord method is the fundamental name/implementation dispatch mechanism
The return value and arguments can be abstracted

       FunctionResult* doRecord(FunctionArguments* args)

Action is an implementation of FunctionArguments
ActionResult is an implementation of FunctionResult

that's all you need to generate the boilerplate code, everything else is
above (implementation of result/args) and below (implementation of what record does)

Probably easiest short term to have concrete models for the args/result but those
could be abstracted.

This is what ExValue does.  It implements the get/set payload but could also be an
interface.

This is directional, what needs to be hand written?

    something getValue()

getValue knows where the value is stored, e.g the Preset

    int value = contextPreset->getSybcycles()

and it needs to make something that the caller can understand

    ExValue v (implements ParameterValueInterface)
    v.setInt(value)
    return v;

OR since this is all depending on calling context, could make the caller pass in the
result container

    void getSubcycles(ParameterValueContainer *container)
    container->setValue(preset->getSubcycles);

yeah, we're back to data types.  Container needs to implement methods that can take all possible
data types.  Like ExValue but abstract.

Think about end-to-end problems:

Script:
   set subcycles 4
   ScriptInterpreter needs to know
     - get me the Parameter object that defines "subcycles"
     - place "4" in a value payload
     - get the current runtime context that handles parameters, ParameterContext
     - call ParameterContext::setValue(Parameter, Payload)
     - ugh, no, this is where it breaks down for scripts, because the execution context
       can't include compiled code have to do a name/id lookup from Parameter to
       something that implements it, so still need a runtime dispatch

MIDI/Key binding
  - MIDI note 42 sets "subcycles" to number 4
  - place number 4 in a payload
  - get the ParameterContext
  - ParameterContext::setValue(Parameter, payload)
  - same problem a binding can't have compiled code

Host parameter binding
  - basically the same as MIDI binding

Yeah, that's what isn't working, there is no situation where there can
be compiled code on the callers side, it is always working from a parameter identifier.
Concrete methods in an interface doesn't help:

   Context
       void setSubcycles(int)

because a binding doesn't know how to call that code, it needs to pass through
something that does the id/method dispatch.

Once IN that code, there can be an abstraction for where the value goes.

   void setParameter(int parameterId, int value)
      switch (parameterId) {
         case Subcycles:
             handler->setSubcycles(value);

Think about "interning" again.

Everything has to start from a name or an id and get to something that
has compiled code.

"core" - a complex system full of compiled code
"parameter" - data that can pass in and out of the core
"context" - something that wants to pass data in and out of the core

Context can't know anythin about the implementation of a parameter, it
only knows a name or an id.

There needs to be a way to quicly map a name/id to an object that implements
core code to get/set the value.

This mapping object must be compiled.

The association of a name/id to this object may require a search, but the
result can be "interned".

What interning looks like is defined by the context, not the core.

There can be many of these mapping objects, or there could be just a shared one.

Currently Parameter is this mapping object.

If you use a shared mapping object, you have the same dispatching problem at the
next level.  How to you get from an id to compiled code.

So really, interning does not help unless you have many mapping objects.  If you
have a single mapping object, it's just a "handler" that internally does the mapping.

The simplest mechanism for dispatch is the function table, so the mapping must
reduce a name to an id.  There is no way to avoid id/code mapping, but this CAN be generated.
Once you have that, the sender and receiver can be abstracted.

So we're back to this:

    class ParameterMapper

        void setParameter(int id, ValuePayload value)
          switch (id):
            case 0: receiver->setSubcycles(value);


Fundamentally all parameters must live in a "namespace" of unique ids that
can be used in a jump table.  the receiver implements concrete compile time
methods that can handle the value, the value must be an abstraction object
so it can be compiled

Function pointers/lambdas can be used here as long as they obey a compile time signature.
but the implementation of this, either through function pointers or static code
doesn't matter to the caller of ParameterMapper.

Can parameters be dynamically extended?  Generally this isn't required except for
scripts that want to declare a parameter and be sensntive to them.  They can
register an id for lookup, but the a compiled switch statement can't be used
for the jump table since the ids are not known at compile time.

Dynamic parameters are must be "registered" at runtime with ids placed
in an extensible array.  A mechanism exists to map a name to an id at runtime.
When a context wants to set a dynamic parameter a destination is found in the
dynamic jump table but this cannot be compiled code, it could however be a pointer
to something that implements an interface.

But this interface just moves the problem.  You can get from an id to an interface
but the intererface code can't be compiled.  In the case of scripts that's fine, the
interface is something that looks up the script to inerpret and runs it.  This works.
Dynamic parameters can only be implemented by scripts.

Ignore dynamics for awhile, starting from the bottom we must have

     set of parameter ids
       const int ParameterSubcycles = 0;
       const int ParameterMultiplyMode = 1;
       ...

This is all you need to integrate the outside world with the core.  Complex definition
of those parameters can be done with a dynamic data mode or static.  what maps
between them is a jump table indexed by id whose value is a ParameterDeifnition.  Wher
that object comes from doesn't matter.  Compiled code cannot reference those objects
it can only use the id.  This is where Parameter constant objects is wrong.  Code
should be using the id constant not the object, and get the object through a table.

On top of that can be build something that converts symbolic names to ids.

That's what you need, everything else falls from that.

To define Parameters in XML, the XML needs to include the id number.  Could you have
a symbolic name in the XML?

   <Parameter name='subcycles'

How to you get from "subcycles" to 0?
You have to search a table of names that know the number.
Who built that table if the names can't be known at runtime?  The can't the
name comes from xml, the linkagage between the name and the number needs to then
BE in the XML which means <Parameter> must have a number.  OR you must have a tuple:

class ParameterDefinition {
   int id;
   const char* name;
};

So a parameter needs to be identified by name so they can be referenced by the outside.
And they need to be defined by id so compile time jump tables can be built.  and we
need a mapping between them.  You can't do this:

        void setParameter(int id, ValuePayload value)
          switch (id):
            case 0: receiver->setSubcycles(value);

without knowing the numbers at compile time.  So the current "ordinal" concept doesn't work
for switch statements.  You can generate an ordinal array at runtime, but that doesn't
get you to setSubcycles.

To avoid the tuple, XML would have to know the raw id numbers.
With the tuple, XML can just have the name, which is more convenient.

Deifning a tuple is not much more complicated than just a const int, rather than this

   switch (id)

you would have to do this

   switch (parameterContantant->id)

Hmm, but the compiler might now know to optimize this because of the indirection.

This gets you there but it a little ugly.


typedef enum
   ParameterSubcycles,
   ParameterMultiplyMode
   ...
};

const char* ParameterNames = [
  "subcycles",
  "multiplyMode"
  ...
  ];

But most code doesn't need to care about that, it just knows it can go from ParameterSubcycles
to an object.  Hmm, enum is probably necessary to ensure the compiler knows the range of values.
just switching on an "int" member won't convey the range.

So parameterIds must be in an enum.  Canonical parameter names must be in an array
indexed by that enum.  Switches compile optimized.  Parameter definition objects can be
constructed at runtime.  ParameterMappers can be generated.

Same for Functions.

The receiver for the core parameter mapper must implement setSubcycles, getSubcycles
but whether that is a bunch of static objects or a single handler doesn't matter.

Well it does matter for the abstraction.  If it is many objects then you need

    class SubcyclesParameterInterface
       void setSubcycles(value);
       value = getSubcycles();

vs.

    class ParameterHandler

       void setSubcycles(value);
       value = getSubcycles();

       void setMultiplyMode(value);
       value = getMultiplyMode();

The later is what you're trying to get to anyway.

The distinction between UI and Core parameters kind of messes this up.  If they
all live in one namespace, then the core handler implemtnations need to have
stub methods for all the UI parameters.

If they live in different namespaces, then a scope needs to be included in the
fundamental parameter definition


    enum {
       SubcyclesParameter =  0;

     } CoreParameters;

    enum {
       WidgetParameter = 0;
     } UIParameters;

Messy?  Maybe not.  From the outside world you start with a name, "widget"

To get to a handler at runtime need to find which ParameterHandler can deal with that name.
From that point forward you're dealing with the handler and an id.  But you can't assume
that the same handler will be used for all parameters identified by name.

So the Parameter can point to it's handler?

Code can deal with different enumeration sets, but this becomes part of othe
signature of the code there is no doSomething(int parameterId
there is doSomethhing(UIParameterId), doSomething(CoreParameterId)

Maybe or is it this

   Handler = findHandler(UIParameterId);
   Handler = findHandler(CoreParameterId);

   Handler = findHandler(name);


names must live in a unique namespace.  Ids don't but something needs to be able to
map the unique name into an "id space" and that id space requiires different handlers.






    





    





  

   

   



**********************************************************************


Parameters that do things other than just set the MobiusConfig value

----------------------------------------------------------------------
Global
----------------------------------------------------------------------

There is a common Export/Action handler that does the obvious thing
from/to the MobiusConfig.  Where it looks like things were done twice,
it was the main/interrupt config.

void GlobalParameter::getValue(Export* exp, ExValue* value)
{
	Mobius* m = (Mobius*)exp->getMobius();
    if (m == NULL) {
        Trace(1, "Mobius not passed in Export!\n");
		value->setNull();
    }
    else {
        // for gets use the external one
        // !! think about this, should we consistently use the interrupt 
        // config, it probably doesn't matter since only scripts
        // deal with most globals 
        MobiusConfig* config = m->getConfiguration();
        getValue(config, value);
    }
}

void GlobalParameter::setValue(Action* action)
{
	Mobius* m = (Mobius*)action->mobius;
    if (m == NULL)
	  Trace(1, "Mobius not passed in Action!\n");
    else {
        MobiusConfig* config = m->getConfiguration();
        setValue(config, &(action->arg));

        config = m->getConfiguration();
        if (config != NULL)
          setValue(config, &(action->arg));
    }
}

/**
 * For bindings, we not only update the config object, we also propagate
 * the change through the engine.
 * For scripts accept a name or a number.
 * Number is 1 based like SetupNumberParameter.
 *
 * This is one of the rare overloads to get the Action so we
 * can check the trigger.
 */
void SetupNameParameterType::setValue(Action* action)
{
	Mobius* m = (Mobius*)action->mobius;
	if (m == NULL)
	  Trace(1, "Mobius not passed in Action!\n");
    else {
        MobiusConfig* config = m->getConfiguration();

        Setup* setup = NULL;
        if (action->arg.getType() == EX_INT)
          setup = config->getSetup(action->arg.getInt());
        else 
          setup = config->getSetup(action->arg.getString());

        if (setup != NULL) {
            // Set the external one so that if you open the setup
            // window you'll see the one we're actually using selected.
            // in theory we could be cloning this config at the same time
            // while opening the setup window but worse case it just gets
            // the wrong selection.

            // !! allocates memory
            config->setStartingSetupName(setup->getName());

            // then set the one we're actually using internally
            m->setActiveSetup(setup->ordinal);
        }
    }
}

void SetupNumberParameterType::setValue(Action* action)
{
    Mobius* m = action->mobius;
    // validate using the external config
    MobiusConfig* config = m->getConfiguration();
    int index = action->arg.getInt();
    Setup* setup = config->getSetup(index);

    if (setup != NULL) {
        // we're always in the interrupt so can set it now
        m->setActiveSetup(index);
    }
}

void TrackParameterType::setValue(Action* action)
{
    Mobius* m = (Mobius*)action->mobius;
	// let this be 1 based in the script
	int ivalue = action->arg.getInt() - 1;
	m->setActiveTrack(ivalue);
}

/**
 * Binding this is rare but we do set it in test scripts.
 * For this to have any meaning we have to propagate it to the
 * AudioFade class.  
 */
void FadeFramesParameterType::setValue(Action* action)
{
    int frames = action->arg.getInt();

    // don't bother propagating to the interrupt config, we only
    // need it in AudioFade
	MobiusConfig* config = action->mobius->getConfiguration();
	config->setFadeFrames(frames);

    AudioFade::setRange(frames);
}

/**
 * Binding this is rare but we occasionally set this in test scripts.
 * For this to have any meaning, we also need to propagate it to the
 * Synchronizer which keeps a cached copy.  Also copy it to the interrupt
 * config just so they stay in sync though that isn't used.
 */
void MaxSyncDriftParameterType::setValue(Action* action)
{
    int drift = action->arg.getInt();

    Mobius* m = (Mobius*)action->mobius;
	MobiusConfig* config = m->getConfiguration();
	config->setMaxSyncDrift(drift);

    MobiusConfig* iconfig = m->getConfiguration();
    if (iconfig != NULL) {
        iconfig->setMaxSyncDrift(drift);
        Synchronizer* sync = m->getSynchronizer();
        sync->updateConfiguration(iconfig);
    }
}

/**
 * Binding this is rare but we occasionally set this in test scripts.
 * For this to have any meaning, we also need to propagate it to the
 * Synchronizer which keeps a cached copy.  Also copy it to the interrupt
 * config just so they stay in sync though that isn't used.
 */
void DriftCheckPointParameterType::setValue(Action* action)
{
    DriftCheckPoint dcp = (DriftCheckPoint)getEnum(&(action->arg));

    Mobius* m = (Mobius*)action->mobius;
	MobiusConfig* config = m->getConfiguration();
	config->setDriftCheckPoint(dcp);

    MobiusConfig* iconfig = m->getConfiguration();
    if (iconfig != NULL) {
        iconfig->setDriftCheckPoint(dcp);
        Synchronizer* sync = m->getSynchronizer();
        sync->updateConfiguration(iconfig);
    }
}

void CustomModeParameterType::setValue(Action* action)
{
    Mobius* m = (Mobius*)action->mobius;
	m->setCustomMode(action->arg.getString());
}

/**
 * Binding this is rare but we do set this in test scripts.
 * For this to have any meaning we have to propagate this to the
 * Loops via the Tracks.
 */
void AutoFeedbackReductionParameterType::setValue(Action* action)
{
    bool afr = action->arg.getBool();

    Mobius* m = (Mobius*)action->mobius;
    MobiusConfig* config = m->getConfiguration();
    config->setAutoFeedbackReduction(afr);

    MobiusConfig* iconfig = m->getConfiguration();
    if (iconfig != NULL) {
        iconfig->setAutoFeedbackReduction(afr);

        for (int i = 0 ; i < m->getTrackCount() ; i++) {
            Track* t = m->getTrack(i);
            t->updateGlobalParameters(iconfig);
        }
    }
}

/**
 * Binding this is rare, but we do set it in test scripts.
 * For this to have any meaning we need to propagate it to the
 * interrupt config where Track will look at it, and also 
 * to the Recorder.
 *
 * UPDATE: Recorder is gone and we lost the abillity to do this.
 * Redesign if we think it is still useful.
 */
void MonitorAudioParameterType::setValue(Action* action)
{
    bool monitor = action->arg.getBool();

    Mobius* m = (Mobius*)action->mobius;
    MobiusConfig* config = m->getConfiguration();
	config->setMonitorAudio(monitor);
#if 0
    Recorder* rec = m->getRecorder();
    if (rec != NULL)
      rec->setEcho(monitor);
#endif
}

/**
 * Binding this is rare but we do set it in test scripts.
 * For this to have any meaning we have to propagate it to the
 * Audio class.  
 */
void IntegerWaveFileParameterType::setValue(Action* action)
{
    bool isInt = action->arg.getBool();
    // don't bother propagating this to the interrupt config
    Mobius* m = (Mobius*)action->mobius;
    MobiusConfig* config = m->getConfiguration();
	config->setIntegerWaveFile(isInt);

    // this shouldn't be a parameter and we should be dealing with
    // files at a higher level
    Trace(1, "IntegerWaveFileParameterType: setWriteFormat!\n");
    //Audio::setWriteFormatPCM(isInt);
}

/**
 * Binding this is impossible but we might set it in a test script.
 * For this to have any meaning we have to propagate it to the
 * Funtion class.
 *
 * Changing this in an action was removed see also
 * ConfirmationFunctionsParameterType
 */
void MuteCancelFunctionsParameterType::setValue(Action* action)
{
    // don't bother propagating to the interrupt
    Mobius* m = (Mobius*)action->mobius;
	MobiusConfig* config = m->getConfiguration();
	if (action->arg.isNull())
	  config->setMuteCancelFunctions(NULL);
	else
	  config->setMuteCancelFunctions(new StringList(action->arg.getString()));

    // this is normally called by installConfig when the
    // scripts are compiled, here we track dynamic changes
    Trace(1, "MuteCancelFunctionsParameter: Action handler wants to updateGlobalFunctionPreferences!\n");
    //m->updateGlobalFunctionPreferences();
}

/**
 * Binding this is impossible but we might set it in a test script.
 * For this to have any meaning we have to propagate it to the
 * Funtion class.
 *
 * UPDATE: removed Mobius::updateGlobalFunctionPreferences
 * during the initialization redesign.  Could add something
 * similar back, but scripts should not be needing to do this.
 * What this did is done by initialize() and reconfigure() working
 * from the MobiusConfig.
 * 
 */
void ConfirmationFunctionsParameterType::setValue(Action* action)
{
    // don't bother propagating to the interrupt
    Mobius* m = (Mobius*)action->mobius;
	MobiusConfig* config = m->getConfiguration();
	if (action->arg.isNull())
	  config->setConfirmationFunctions(NULL);
	else
	  config->setConfirmationFunctions(new StringList(action->arg.getString()));

    // this is normally called by installConfig when the
    // scripts are compiled, here we track dynamic changes
    Trace(1, "ConfirmationFunctionsParameter: Action handler wants to updateGlobalFunctionPreferences!\n");
    //m->updateGlobalFunctionPreferences();
}
/**
 * Binding this is rare but we occasionally set this in test scripts.
 * For this to have any meaning, we also need to propagate it to the
 * Synchronizer which keeps a cached copy.  Also copy it to the interrupt
 * config just so they stay in sync though that isn't used.
 */
void MidiRecordModeParameterType::setValue(Action* action)
{
    MidiRecordMode mode = (MidiRecordMode)getEnum(&(action->arg));

    Mobius* m = (Mobius*)action->mobius;
    MobiusConfig* config = m->getConfiguration();
	config->setMidiRecordMode(mode);

    MobiusConfig* iconfig = m->getConfiguration();
    if (iconfig != NULL) {
        iconfig->setMidiRecordMode(mode);
        Synchronizer* sync = m->getSynchronizer();
        sync->updateConfiguration(iconfig);
    }
}

/**
 * Binding this is rare but we do set this in test scripts.
 * For this to have any meaning we have to propagate this to the
 * Streams and the Loops via the Tracks.
 */
void InputLatencyParameterType::setValue(Action* action)
{
    int latency = action->arg.getInt();
    
    Mobius* m = (Mobius*)action->mobius;
	MobiusConfig* config = m->getConfiguration();
	config->setInputLatency(latency);
    
    MobiusConfig* iconfig = m->getConfiguration();
    if (iconfig != NULL) {
        iconfig->setInputLatency(latency);

        for (int i = 0 ; i < m->getTrackCount() ; i++) {
            Track* t = m->getTrack(i);
            t->updateGlobalParameters(iconfig);
        }
    }
}

/**
 * Binding this is rare but we do set this in test scripts.
 * For this to have any meaning we have to propagate this to the
 * Streams and Loops via the Tracks.
 */
void OutputLatencyParameterType::setValue(Action* action)
{
    int latency = action->arg.getInt();

    Mobius* m = (Mobius*)action->mobius;
	MobiusConfig* config = m->getConfiguration();
	config->setOutputLatency(latency);

    MobiusConfig* iconfig = m->getConfiguration();
    if (iconfig != NULL) {
        iconfig->setOutputLatency(latency);

        for (int i = 0 ; i < m->getTrackCount() ; i++) {
            Track* t = m->getTrack(i);
            t->updateGlobalParameters(iconfig);
        }
    }
}

----------------------------------------------------------------------
Preset
----------------------------------------------------------------------

void PresetParameter::getValue(Export* exp, ExValue* value)
{
    Track* track = exp->getTrack();
    if (track != NULL)
	  getValue(track->getPreset(), value);
    else {
        Trace(1, "PresetParameter:getValue track not resolved!\n");
        value->setNull();
    }
}

void PresetParameter::setValue(Action* action)
{
    Track* track = action->getResolvedTrack();
    if (track != NULL)
      setValue(track->getPreset(), &(action->arg));
    else
      Trace(1, "PresetParameter:setValue track not resolved!\n");
}

As expected, these just locate the track's active Preset and use the
structure accessors.

/**
 * Formerly "traditional" was our old broken way and "new" was
 * the fixed way.  "normal" is now "new", "traditional" no longer
 * exists.  "simple" was formerly known as "overdub".
 */
void MultiplyModeParameterType::setValue(Preset* p, ExValue* value)
{
    // auto-upgrade, but don't trash the type if this is an ordinal!
    if (value->getType() == EX_STRING) {
        const char* str = value->getString();
        if (StringEqualNoCase(str, "traditional") || StringEqualNoCase(str, "new"))
          value->setString("normal");

        else if (StringEqualNoCase(str, "overdub"))
          value->setString("simple");
    }

	p->setMultiplyMode((Preset::MultiplyMode)getEnum(value));
}

void EmptyLoopActionParameterType::setValue(Preset* p, ExValue* value)
{
    // catch a common misspelling
    if (value->getType() == EX_STRING && 
        StringEqualNoCase(value->getString(), "copyTiming"))
      p->setEmptyLoopAction(Preset::EMPTY_LOOP_TIMING);

    // support for an old value
    else if (value->getType() == EX_STRING &&
             StringEqualNoCase(value->getString(), "copySound"))
      p->setEmptyLoopAction(Preset::EMPTY_LOOP_COPY);
      
    else
      p->setEmptyLoopAction((Preset::EmptyLoopAction)getEnum(value));
}

/**
 * NOTE: Setting this from a script will not have any effect since
 * Track does not watch for changes to this parameter.  We need to
 * intercept this at a higher level, probably in setValue where
 * it has the Action and inform the Track after we change the 
 * Preset.
 * 
 * Still, I'm not sure I like having the loop count changing willy nilly.
 * only allow it to be changed from the prest?
 */
void LoopCountParameterType::setValue(Preset* p, ExValue* value)
{
	// this will be constrained between 1 and 16
	p->setLoops(value->getInt());
}

void MuteModeParameterType::setValue(Preset* p, ExValue* value)
{
    // auto-upgrade, but don't trash the type if this is an ordinal!
    if (value->getType() == EX_STRING && 
        StringEqualNoCase(value->getString(), "continuous"))
      value->setString("continue");

	p->setMuteMode((Preset::MuteMode)getEnum(value));
}

void RecordTransferParameterType::setValue(Preset* p, ExValue* value)
{
    // ignore restore mode
    Preset::TransferMode mode = (Preset::TransferMode)getEnum(value);
    if (mode != Preset::XFER_RESTORE)
      p->setRecordTransfer((Preset::TransferMode)mode);
}

Presets are easy, they are almost all just structure accessors with
a few scattered name change upgrades.  Will want to put aliases back in
for old scripts.

----------------------------------------------------------------------
Setup
----------------------------------------------------------------------

/**
 * Locate the target setup for the export.
 */
Setup* SetupParameter::getTargetSetup(Mobius* m)
{
    // assuming this should be the active setup, not necessarily
    // the starting setup
    Setup* target = m->getActiveSetup();

    if (target == NULL)
		Trace(1, "SetupParameter: Unable to resolve setup!\n");

    return target;
}

void SetupParameter::getValue(Export* exp, ExValue* value)
{
	Setup* target = getTargetSetup(exp->getMobius());
    if (target != NULL)
      getValue(target, value);
    else
      value->setNull();
}

void SetupParameter::setValue(Action* action)
{
	Setup* target = getTargetSetup(action->mobius);
    if (target != NULL)
      setValue(target, &(action->arg));
}

Export and actons just do their thing on the active setup

int DefaultSyncSourceParameterType::getOrdinalValue(Setup* s)
{
    // the enumeration has "Default" as the first item, we hide that
    int index = (int)s->getSyncSource();
    if (index > 0)
      index--;
    return index;
}
   -- that seems wrong?

void DefaultSyncSourceParameterType::setValue(Setup* s, ExValue* value)
{
    // the enumeration has "Default" as the first item, we hide that
    if (value->getType() == EX_INT)
      s->setSyncSource((SyncSource)(value->getInt() + 1));
    else {
        int index = getEnum(value) + 1;
        s->setSyncSource((SyncSource)index);
    }
}

the same little "Default" dance happens in a few other places

int DefaultTrackSyncUnitParameterType::getOrdinalValue(Setup* s)
{
    // the enumeration has "Default" as the first item, we hide that
    int index = (int)s->getSyncTrackUnit();
    if (index > 0)
      index--;
    return index;
}

void OutRealignModeParameterType::setValue(Setup* s, ExValue* value)
{
    // upgrade old value
    const char* str = value->getString();
    if (StringEqualNoCase(str, "retrigger"))
      value->setString("restart");

	s->setOutRealignMode((OutRealignMode)getEnum(value));
}

----------------------------------------------------------------------
Track
----------------------------------------------------------------------

void TrackParameter::setValue(Action* action)
{
    Track* track = action->getResolvedTrack();
    if (track != NULL)  
      setValue(track, &action->arg);
}

/**
 * Default getter for an Export.  This does the common
 * work of digging out the resolved Track.
 */
void TrackParameter::getValue(Export* exp, ExValue* value)
{
    Track* track = exp->getTrack();
    if (track != NULL)
      getValue(track, value);
	else
      value->setNull();
}

/**
 * The Speed and Pitch parameters change latency so they must be scheduled
 * as functions rather than having an immediate effect on the track like
 * most other parameters.
 *
 * This is called to convert the parameter action into a function action
 * and invoke it.
 */
void TrackParameter::doFunction(Action* action, Function* func)
{
    // this flag must be on for ScriptInterpreter
    if (!scheduled)
      Trace(1, "Parameter %s is not flagged as being scheduled!\n",
            getName());

    // Convert the Action to a function
    action->setFunction(func);

    // parameter bindings don't set this, need for functions
    action->down = true;
    action->escapeQuantization = true;
    action->noTrace = true;

    Mobius* m = (Mobius*)action->mobius;
    m->doActionNow(action);
}

For the most part, the only thing different about Track parameters is that the
use Track as their underlying model in addition to SetupTrack.  So these will
need to all be defined.  

void TrackNameParameterType::getValue(Track* t, ExValue* value)
{
	value->setString(t->getName());
}

void TrackNameParameterType::setValue(Track* t, ExValue* value)
{
    t->setName(value->getString());
}

void FocusParameterType::getValue(Track* t, ExValue* value)
{
    value->setBool(t->isFocusLock());
}

void FocusParameterType::setValue(Track* t, ExValue* value)
{
	t->setFocusLock(value->getBool());
}

void GroupParameterType::setValue(Track* t, ExValue* value)
{
	Mobius* m = t->getMobius();
    MobiusConfig* config = m->getConfiguration();
	int maxGroup = config->getTrackGroups();

	int g = value->getInt();
	if (g >= 0 && g <= maxGroup)
	  t->setGroup(g);
    else {
        // also allow A,B,C since that's what we display
        const char* str = value->getString();
        if (str != NULL && strlen(str) > 0) {
            char letter = toupper(str[0]);
            if (letter >= 'A' && letter <= 'Z') {
                g = (int)letter - (int)'A';
                if (g >= 0 && g <= maxGroup)
                  t->setGroup(g);
            }
        }
    }
}

void FeedbackLevelParameterType::setValue(Track* t, ExValue* value)
{
    int v = value->getInt();
    if (v >= low && v <= high)
      t->setFeedback(v);
}
   -- smattering of range checks for some reason

void SpeedOctaveParameterType::setValue(Action* action)
{
    doFunction(action, SpeedOctave);
}
  -- collection of weird parameters that turn into functions

/**
 * The range is configurable for the SpeedShift spread function
 * but mostly so that we don't claim notes that we could use
 * for something else.  The parameter doesn't have that problem
 * as it is bound to a single CC.  We could assume a full CC 
 * range of 64 down and 63 up, but we've been defaulting
 * to a 48 step up and down for so long, let's keep that so
 * if someone binds a CC to this parameter or to the SpeedShift
 * function they behave the same.  I don't think we need
 * to configure a range here but it would make a pedal less
 * twitchy and easier to control.
 */
SpeedStepParameterType::SpeedStepParameterType() :

void TrackPresetParameterType::getValue(Track* t, ExValue* value)
{
    const char* name = NULL;

    // You usually want the string for display.
    // Unfortunately the private track preset did not copy
    // the name to avoid memory allocation so we have to go back
    // to the MobiusConfig.  Note also that Track::mPreset came 
    // from the interrupt config but for the outside view of the
    // parameter we need to use the master config.  This can result
    // in a small window of inconsistency if we're in the middle of 
    // shifting a new configuration down.  Since this is only used for the UI
    // it should correct itself quickly.

    MobiusConfig* iconfig = t->getMobius()->getConfiguration();
    Preset* p = t->getPreset();
    if (p != NULL) 
      name = p->getName();
    else {
        // should only happen if we're shifting down a new config object
        // and one or more of the presets were deleted
        Trace(1, "ERROR: TrackPresetParameter: Unable to determine preset name\n");
    }

	value->setString(name);
}
/**
 * This is one of the unusual ones that overloads the Action signature
 * so we can get information about the trigger.
 */
void TrackPresetParameterType::setValue(Action* action)
{
	// accept either a name or index
	Mobius* m = action->mobius;
	MobiusConfig* config = m->getConfiguration();

	// value may be string or int, ints are used in the
	// ParameterDisplay component 
	Preset* preset = NULL;
	if (action->arg.getType() == EX_INT)
	  preset = config->getPreset(action->arg.getInt());
	else 
	  preset = config->getPreset(action->arg.getString());

	if (preset != NULL) {
        Track* t = action->getResolvedTrack();

        if (action->trigger != TriggerScript) {
            // !! assume this has to be pending for safety, though
            // we'll always be in a script?
            // We should be doing this with Actions now rather than
            // yet another type of pending
            t->setPendingPreset(preset->ordinal);
        }
        else {
            // do it immediately so the reset of the script sees it
            // !! should be getting this from the interrupt config?
            t->setPreset(preset->ordinal);
        }
	}
}

void TrackPresetNumberParameterType::setValue(Action* action)
{
	Mobius* m = action->mobius;
	MobiusConfig* config = m->getConfiguration();
    int index = action->arg.getInt();
	Preset* preset = config->getPreset(index);

	if (preset != NULL) {
        Track* t = action->getResolvedTrack();
        if (action->trigger != TriggerScript) {
            // !! assume this has to be pending for safety, though
            // we'll always be in a script?
            // Should be doing this with deferred Actions now
            t->setPendingPreset(index);
        }
        else {
            t->setPreset(index);
        }
	}
}

/**
 * Given an ordinal, map it into a display label.
 * If the value is "default", we qualify it to show what the
 * default mode is.
 */
void SyncSourceParameterType::getOrdinalLabel(Mobius* m,
                                                     int i, ExValue* value)
{
    // should always have these
	if (valueLabels == NULL)
      value->setInt(i);
    else {
		value->setString(valueLabels[i]);
        if (i == 0) {
            // add a qualifier
            // Actually the qualifer makes this rather long so don't
            // bother showing "Default", just wrap it
            value->setString("(");
            ExValue v2;
            DefaultSyncSourceParameter->getDisplayValue(m, &v2);
            value->addString(v2.getString());
            value->addString(")");
        }
	}
}

----------------------------------------------------------------------

Really not that much here.  The globals have the most weird side effects.

Parameter and Setup are almost all just structure accessors.

Track is the one that has a completely different model for Export/Action

How to dispatch Action on a Track parameter

    doAction(UIParameter* p, ExValue value)
      Track* t = getTargetTrack()'

      if (p == InputLevelParameter)
         t->setInputLevel(value.getInt());

      else if (p == OutputLevelParameter)
         t->setOutputLevel(...

If we had such a thing as a scoped parameter orginal

      switch (p->actionOrdinal) {
         case 0: t->setInputLevel(v);
         case 1: t->setOutputLevel(v);

Supposed to compile into a jump table.  Managing the enum for the ordinals
is the awkward part, but easier than a full blown Parameter class.


