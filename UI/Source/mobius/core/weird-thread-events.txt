/**
 * SaveCapture global function handler.
 * 
 * Since this involves file IO, have to pass it to the thread.
 */
void Mobius::saveCapture(Action* action)
{
    const char* file = NULL;
    if (action != NULL && action->arg.getType() == EX_STRING)
      file = action->arg.getString();

	ThreadEvent* te = new ThreadEvent(TE_SAVE_AUDIO, file);
    if (action != NULL)
      action->setThreadEvent(te);

	mThread->addEvent(te);
}


why would this need to be saved on the thread?
oh, is this an Action generated by a script?  seems backwards
script should be allocating and scheduling the event 


/**
 * Special internal target used to notify running scripts when
 * something interesting happens on the outside.
 * 
 * Currently there is only one of these, from MobiusTread when
 * it finishes processing a ThreadEvent that a script might be waiting on.
 *
 * Note that this has to be done by probing the active scripts rather than
 * remembering the invoking ScriptInterpreter in the event, because
 * ScriptInterpreters can die before the events they launch are finished.
 */
void ScriptRuntime::doScriptNotification(Action* a)
{
    if (a->trigger != TriggerThread)
      Trace(1, "Unexpected script notification trigger!\n");

    // unusual way of passing this in, but target object didn't seem
    // to make sense
    ThreadEvent* te = a->getThreadEvent();
    if (te == NULL)
      Trace(1, "Script notification action without ThreadEvent!\n");
    else {
        for (ScriptInterpreter* si = mScripts ; si != NULL ; 
             si = si->getNext()) {

            // this won't advance the script, it just prunes the reference
            si->finishEvent(te);
        }

        // The ThreadEvent is officially over, we get to reclaim it
        a->setThreadEvent(NULL);
        delete te;
    }
}

Script does this

	ThreadEvent* te = new ThreadEvent(TE_ECHO, msg);
	si->scheduleThreadEvent(te);

	ThreadEvent* te = new ThreadEvent(TE_PROMPT, msg);
	si->scheduleThreadEvent(te);
    ...

most of these are Statement implementations so scripts have the file names
in them and we need to pass them up

        case WAIT_SCRIPT: {
            // wait for any events we've sent to MobiusThread to complete
            // !! we don't need this any more now that we have "Wait thread"
			ThreadEvent* te = new ThreadEvent(TE_WAIT);
			ScriptStack* frame = si->pushStackWait(this);
			frame->setWaitThreadEvent(te);
			si->scheduleThreadEvent(te);
			Trace(3, "Script %s: wait script event\n", si->getTraceName());
		}

unclear what this means but it follows the same pattern

void ScriptInterpreter::scheduleThreadEvent(ThreadEvent* e)
{
	// this is now the "last" thing we can wait for
	// do this before passing to the thread so we can get notified
	mLastThreadEvent = e;
    
    MobiusThread* t = mMobius->getThread();
    t->addEvent(e);
}

ugh, here's the shit to ponder

/**
 * Called after we've processed a function and it scheduled an event.
 * Since events may not be scheduled, be careful not to trash state
 * left behind by earlier functions.
 */
void ScriptInterpreter::setLastEvents(Action* a)
{
	if (a->getEvent() != NULL) {
		mLastEvent = a->getEvent();
		mLastEvent->setScript(this);
	}

	if (a->getThreadEvent() != NULL) {
		mLastThreadEvent = a->getThreadEvent();
		// Note that ThreadEvents don't point back to the ScriptInterpreter
		// because the interpreter may be gone by the time the thread
		// event finishes.  Mobius will forward thread event completion
		// to all active interpreters.
	}
}

I think this is just a transient use of Action::threadEvent meant to pass
this back up the call stack so we can know what to wait on.

So, ScriptInterpreter makes an Action and calls Mobius::doActionNow
At this point the Action may have been given a ThreadEvent that we want to wait on

Yeah, for events scheduled by the Script itself we have this

void ScriptInterpreter::scheduleThreadEvent(ThreadEvent* e)
{
	// this is now the "last" thing we can wait for
	// do this before passing to the thread so we can get notified
	mLastThreadEvent = e;


But for Actions just processed by doActionNow we didn't allocate them

The only ones I can find are:

void Mobius::saveCapture(Action* action)
{
    const char* file = NULL;
    if (action != NULL && action->arg.getType() == EX_STRING)
      file = action->arg.getString();

	ThreadEvent* te = new ThreadEvent(TE_SAVE_AUDIO, file);
    if (action != NULL)
      action->setThreadEvent(te);

	mThread->addEvent(te);
}

This uses it but is different, it's passing it DOWN not up

void MobiusThread::finishEvent(ThreadEvent* e)
{
    Action* a = mMobius->newAction();
    a->trigger = TriggerThread;
    a->setTarget(ActionScript);

    // this is a little unusual because we use this
    // for an input to the action and it's usually a return
    a->setThreadEvent(e);

    mMobius->doAction(a);
}

This did it too

void Mobius::saveLoop(Action* action)
{
	ThreadEvent* te = new ThreadEvent(TE_SAVE_LOOP);

    // optional file name
    if (action->arg.getType() == EX_STRING)
      te->setArg(0, action->arg.getString());
    action->setThreadEvent(te);

	mThread->addEvent(te);
}

So there were only two cases where we need to schedule a ThreadEvent
inside doActionNow, saveLoop and saveCapture.  And I guess you would want to
wait on them.

Strange that TE_SAVE_PROJECT didn't do that, I guess because it was from
a script statement rather than a Function action.


So I guess the general problem is:

   Script invokes a Function
   Function in rare cases wants to schedule a ThreadEvent
   Script wants to wait on that event
   Function needs to pass the ThreadEvent back to Script so it knows what to wait on
   Action is the only object that passes between Script and Function

This seems to be the same way track Events work

That's okay

What was weird about this is that Action::mThreadEvent was overloaded for two
different purposes.  To RETURN the ThreadEvent that was scheduled as a side
effect of invoking a Function.

To SEND a completed ThreadEvent down in an Action from the shell.

We no longer do the second case any more which is nice.  So Action::mThreadEvent is only
used to pass state back to the ScriptInterpreter


