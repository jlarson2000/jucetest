Unit tests make heavy use of these functions

  StartAudioRecording
  StopAudioRecording

  SaveLoop
  SaveAudioRecording
  Diff

The AudioRecording functions are what is internally called "capture".

 * Functions for capturing the audio stream and saving to a file.
 * These are all global functions.

It's basically a simplified resampler, record what is happening in the
engine for a period of time.

The internal function names are these, so I must have changed themn
at some point to get rid of the unweildy "AudioRecording"

  StartCapture
  StopCapture
  SaveCapture

These are simple pass-through functions to the Mobius method

  startCapture
  stopCapture
  saveCapture

This also activates a minor mode "Capture" .

This was used only for unit tests, and isn't fleshed out enough to be of general
use so might want to hide these in the binding windows unless an "advance" mode is enabled.
Same is true for a lot of functions and parameters.  need to think about decluttering
the UI for most users.

Capture implementation is also used for the Bounce function which is more of a
resampler-like feature.  Try to redesign these so they are the same with different
arguments to control how they work.

SaveLoop and SaveCapture are simlar in that they create an Audio that is not
part of the Track/Loop/Layer model and want to save it in files. The general problem is:

   engine is actively doing someting
   audio data needs to be copied
   the copied audio needs to pass from kernel to shell to be saved
   saving requires MobiusContainer to provide pathname support
   ideally MobiusContainer also implements the file handling
   files are mostly Audio .wav files and a few text files for projects

   file save/load needs to be done in the maintenance thread with the script
   waiting on a KernelEvent

The thorny problems are

   engine is active while audio copies are being made
   Audio is huge, and we'd like to avoid copying them as they pass through the
     system layers
   Audio contins blocks that are managed in the core's AudioPool, if these
     escape to the UI, the lifecycle of the Audio must be strictly controlled
     UI must return the Audio to MobiusShell for reclamation

   Since capture audio is not copied, while the Audio is "out" for file saving,
   a function could cause the start of another capture that wants to use the same
   Audio container
     this won't happen in unit tests, but once this evolves into a more general
     resampling feature will need to address this
     will need some sort of release/return mechanism and if an overlaping capture
     is performed during release, we create another Audio

Capture is relatively easy.  Mobius keeps an Audio around just for capture, it can
be filling, or just waiting.  Capture Audio is allowed to escape to the UI temporarily,
while that happens should try to avoid another capture.  Control flow

   StartCapture function
   Mobius prepares mCaptureAudio
   as interrupts happen, mCaptureAudio fills
   ! probably want a governor on this so it doesn't just fill forever
   StopCapture function
   Mobius stops filling mCaptureAudio and waits
   SaveCapture function
   Mobius calls Kernel::saveAudio with the capture Audio
     script provides the base pathname
   Mobius remembers that mCaptureAudio is out for save
     if StartCapture is called again it is ignored
   MobiusKernel passes the Audio and file name to the Shell
     ! file name is generated by a script and will probably be dynamically allocated
     give Audio a small char array to hold the desired file name
     in a future more general capture, UI could prompt for a file name either
     before or during SaveCapture

Save can be done in two ways

  Maintenance thread consumes KernelEvents and finds EventSaveAudio
  Maintenance thread does the save
  Maintenance thread sends completed event back to Kernel
  Kernel tells Mobius it is done
  Mobius makes mCaptureAudio available again
  scripts resume
  
or

  Maintenance thread consumes EventSaveAudio
  Maintenance thread calls MobiusContainer::saveAudio
    - this is basically the same it just moves the code that actually
      writes the .wav file up to the UI level where Juce is easier


or

  Maintenance thread calls MobiusListener to save the Audio
  this is interesting
  whether we use MobiusContainer or MobiusListener the save is not done in the UI thread
  if we're not using Timer, the only way for it to happen in the UI thread would be if the Audio
  was placed in a holding area and not saved until a button or menu item initiated the save
  this can be good actually, the UI keeps pumping along during the save

There is overlap betwene MobiusContainer and MobiusListener.  MobiusListener is currently
used for outbound communication from the engine to the UI.  It takes always takes place in the
maintenance thread, but it always a "push" model.

MobiusContainer has so far been mostly a "pull" model.  It sits there until the engine
wants something, then the engine pulls what it needs.

MobiusContainer could be bidirectional, in addition to the current "get" methods
it can have the same methods that MobiusListener does TimeBoundar, DynamicConfigChanged
and now SaveAudio.

This would simplify the UI/engine interface a bit.  UI must always implement a MobiusContainer
but it then also needs to register a MobiusListener to get callbacks.  The distinction is kind
of nice though for code organization.  JuceMobiusContainer just has to deal with audio/midi devices
and not files or notifying the UI.  Yeah, keep them seperate.

Note that Audio becomes a crucial part of the UI/engine interface. So will Project.  At some point
we may want clean ownership transfers which means the linkage to the AudioPool needs to be more
flexible.   UI and engine should not share the same AudioPool, but an Audio created on either
side should pass completely to the other without dragging over pool references.

This goes back to a fundamental design change, pooled objects are only "in" a pool when they
are being used.  When an object is taken from a pool, it will not necessarily be sent back
to the same pool.  You don't call object->putBackInPool  you call pool->keepThisObject

Ok, so things we need

    Audio needs a static buffer for file names
    KernelEvent needs an event type to pass Audio back and forth
    MobiusListener may eventually need a callback to save files
    MobiusListener WILL need a callback to prompt for a file to load

Ah, loading is related to this and could have a different control flow

  Function/Script wants to load content into a loop
  Core asks Kernel to load a file
  Kernel asks shell to load a file
  Shell uses MobiusListener to ask UI to load a file
  ...time passes...
  UI prompots the user to browse for a file
  UI gives the file name to the shell

Who reads the file, UI or shell?  If shell is going to be saving the file
then it should also be the one that reads it.  This can move at some point but
it should be consistent.

Digression on Function invocation times...
  There are two times when Function::invoke can be called
  1) at the beginning of an interrupt when pending Actions are processed
     and before audio blocks start being processed, this is also when
     scripts are resumed and can call functions
     
  2) in the middle of audio block processing when an Event is reached

In both cases, the system is in a stable state, but it makes a difference
for functions that would want to influence the incoming audio blocks and have
that apply to the tracks.  That only happens with Samples right now which
are always first, but needs thought for the future.


