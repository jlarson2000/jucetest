    GlobalParameter(const char* name, int key) :
        Parameter(name, key) {
        scope = PARAM_SCOPE_GLOBAL;
        mComplained = false;
    }


class LogStatusParameterType : public GlobalParameter
{
  public:
	LogStatusParameterType();
	void getValue(MobiusConfig* c, ExValue* value);
	void setValue(MobiusConfig* c, ExValue* value);
};

LogStatusParameterType::LogStatusParameterType() : 
    GlobalParameter("logStatus", MSG_PARAM_LOG_STATUS)
{
    // not worth bindable
	type = TYPE_BOOLEAN;
}

void LogStatusParameterType::getValue(MobiusConfig* c, ExValue* value)
{
	value->setBool(c->isLogStatus());
}

void LogStatusParameterType::setValue(MobiusConfig* c, ExValue* value)
{
	c->setLogStatus(value->getBool());
}

LogStatusParameterType LogStatusParameterObj;
Parameter* LogStatusParameter = &LogStatusParameterObj;

<parameter name='logStatus' scope='gloal' type='bool'/>
  implied
    displayName='Log Status'
    get='value->setBool(obj->isLogstatus())'
    set='obj->setLogStatus(value->getBool())'
    
  


  



----------------------------------------------------------------------




<!-- experiment to see what Parameter definition in text would look like -->

<Parameter name='switchQuantize'
           displayName="Switch Quantize"
	       values="off, subCycle, cycle, loop, confirm, confirmSubCycle, confirmCycle, confirmLoop"
           displayValues"Off, Subcycle, Cycle, Loop, Confirm, Confirm Subcycle, Confirm Cycle, Confirm Loop"
           bindable='true'
	       type="enum"
           aliases="switchQuant"
           object="Preset"
           method="SwitchQuantize"
           enum="SwitchQuantize">
           comments="Things you might want to know"
           displayStyle="Slider"
         </Parameter>
         

If displayValues are missing, the rule is to take the internal name, capitalize the
first letter and add spaces between subsequent capitalizations.

If this pattern can't be followed

  displayValues="subCycle=Subcycle, confirmSubCycle=Confirm Subcycle"

Generalize for all objects?

<Definition type="Parameter"
            name='switchQuantize'
            displayName="Switch Quantize"
            ...

Really doesn't matter if we don't build a C++ model for each type element
can operate on the Xom model and use the element name as the type name.
Less pure because the XML attribute sets are merged.


multi valued are weird
